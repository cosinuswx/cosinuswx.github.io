<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="测试给andorid编写驱动"><meta name="keywords" content="android,driver"><meta name="author" content="Cosinus Wx"><meta name="copyright" content="Cosinus Wx"><title>测试给andorid编写驱动 | Cosinus.Wx's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '已复制',
    error: '复制失败',
    noSupport: '浏览器不支持复制'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="显示文章目录">显示博客信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">当前已读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、设备与驱动"><span class="toc-text">一、设备与驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-设备驱动代码的基本框架"><span class="toc-text">1. 设备驱动代码的基本框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-初始化设备"><span class="toc-text">2. 初始化设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#①-注册主次设备号"><span class="toc-text">① 注册主次设备号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#②-添加设备"><span class="toc-text">② 添加设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#③-文件操作"><span class="toc-text">③ 文件操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#④-file-结构体"><span class="toc-text">④ file 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#⑤-inode-结构体"><span class="toc-text">⑤ inode 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#⑥-构造驱动所使用的结构体"><span class="toc-text">⑥ 构造驱动所使用的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#⑦-创建设备"><span class="toc-text">⑦ 创建设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-释放设备"><span class="toc-text">3. 释放设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-打开设备"><span class="toc-text">4. 打开设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-编译"><span class="toc-text">5. 编译</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">Cosinus Wx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">快速访问</div><a class="author-info-links__name text-center" href="/about">关于</a><a class="author-info-links__name text-center" href="/atom.xml">RSS</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cosinus.Wx's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">HOME</a><a class="site-page" href="/archives">ARCHIVES</a><a class="site-page" href="/tags">TAGS</a><a class="site-page" href="/categories">CATEGORIES</a><a class="site-page" href="/about">ABOUT</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">测试给andorid编写驱动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-08-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/android/"> android</a></div><div class="article-container" id="post-content"><h2 id="一、设备与驱动"><a href="#一、设备与驱动" class="headerlink" title="一、设备与驱动"></a>一、设备与驱动</h2><p>本文中会创建一个字符设备（<a href="https://github.com/cosinuswx/AndroidMisc/tree/develop/driver/membuff" target="_blank" rel="noopener">源代码</a>），放在 <em>/dev</em> 下面，设备里面为一块内存，里面可以存储一定的内容。如果以写方式打开设备的话，可以往设备里面写入数据，当返回 <em>-ENOSPC</em> 时，表示设备已满，无法再写入。如果以读方式打开设备的话，可以从设备里面读取数据，每次都是从头开始读取，如果没有更多内容的时候，返回0，表示结束。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>

<h3 id="1-设备驱动代码的基本框架"><a href="#1-设备驱动代码的基本框架" class="headerlink" title="1. 设备驱动代码的基本框架"></a>1. 设备驱动代码的基本框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"membuff.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">membuff_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">membuff_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>)</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Memory Buffer Driver"</span>)</span><br><span class="line"></span><br><span class="line">module_init(membuff_init);</span><br><span class="line">module_exit(membuff_exit);</span><br></pre></td></tr></table></figure>

<p><em>MODULE_LICENSE</em> 用来告诉内核这个模块所使用的授权协议，如果没有这个声明的话，内核在加载这个模块的时候，就会报错。</p>
<p><em>MODULE_DESCRIPTION</em> 用来展示一个人类可读的文本，描述该模块的用处。</p>
<p><em>module_init</em> 和 <em>module_exit</em> 用来指定模块被加载和被卸载时，内核需要调用的函数，<em>__init</em> 和 <em>__exit</em> 用来表示这两个函数只能在加载或者卸载的时候使用，在其他场景下使用都会报错。</p>
<h3 id="2-初始化设备"><a href="#2-初始化设备" class="headerlink" title="2. 初始化设备"></a>2. 初始化设备</h3><h4 id="①-注册主次设备号"><a href="#①-注册主次设备号" class="headerlink" title="① 注册主次设备号"></a>① 注册主次设备号</h4><p>主设备号用来关联该设备所使用的驱动程序，可以多个设备使用同一个驱动程序，但是一般情况下都是一个设备对应于一个驱动程序。而次设备号，驱动程序用来区分具体的设备。</p>
<p>主次设备号可以静态分配，也可以动态分配。静态分配的设备号，一般用于非常常见的设备，少数人使用的设备需要使用动态分配，否则容易和其他人分配的设备号冲突。</p>
<p>动态分配逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">err = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, MEMORY_BUFF_NODE_NAME);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	printk(KERN_ALERT<span class="string">"Failed to alloc char dev region.\n"</span>);</span><br><span class="line">	<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">devMajor = MAJOR(dev);</span><br><span class="line">devMinor = MINOR(dev);</span><br></pre></td></tr></table></figure>

<p><em>alloc_chrdev_region</em> 用来动态分配一定范围的设备号，原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> firstminor,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>dev</em> 是一个输出参数，在成功的时候，返回设备号范围的第一个数。<em>firstminor</em> 用来指定 <em>minor</em> 的第一个数值，一般都为0。<em>count</em> 指定需要分配的范围。<em>name</em> 指定设备的名称。</p>
<h4 id="②-添加设备"><a href="#②-添加设备" class="headerlink" title="② 添加设备"></a>② 添加设备</h4><p>内核内部使用 <em>struct cdev</em> 来表示一个字符设备，因此添加设备之前需要先构造这样一个结构体，可以通过下面的方式分配及初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">my_cdev</span> = <span class="title">cdev_alloc</span>();</span></span><br><span class="line">my_cdev-&gt;ops = &amp;my_fops;</span><br></pre></td></tr></table></figure>

<p>除了使用动态分配 <em>cdev*，还可以将 *cdev</em> 放在其他结构体里面，但是这个时候，就得使用下面的函数来初始化了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, struct file_operations *fops)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>ops</em> 待会介绍，初始化完了后，可以通过 <em>cdev_add</em> 将这个设备注册到系统中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devno = MKDEV(membuf_device_major, membuf_device_minor);</span><br><span class="line"></span><br><span class="line">err = cdev_add(my_cdev, devno, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">	printk(KERN_ALERT<span class="string">"Failed to add char device.\n"</span>);</span><br><span class="line">	<span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>cdev_add</em> 的第二个参数是指定该设备对应的第一个设备号，<em>count</em> 指定该设备有多少个设备号，通常情况下是一个。调用 <em>cdev_add</em> 需要注意两点：</p>
<ol>
<li>cdev_add 可能会调用失败，所以需要检查返回值</li>
<li>一旦 cdev_add 调用成功，那么该设备就以及添加到系统中了，其对应的操作可以被调用，因此需要保证在此之前所有相关的逻辑都执行完了</li>
</ol>
<h4 id="③-文件操作"><a href="#③-文件操作" class="headerlink" title="③ 文件操作"></a>③ 文件操作</h4><p>目前，我们已经将设备准备好了，但是对文件的操作（比如 <em>read</em>、<em>write</em>）是怎么与设备关联起来的呢？</p>
<p>应用程序调用 <em>read</em> 、<em>write</em> 访问文件的时候，会先进入系统调用，最后转到设备驱动的相关函数。系统调用是通过字符设备结构体 <em>struct cdev</em> 中的 <em>ops</em> 来找到对应的设备相关的操作。</p>
<p><em>ops</em> 是一个 <em>file_operations</em> 类型，<em>file_operations</em> 结构体的大多数成员是一个函数指针，对应于这个设备中实现特定操作的函数，如果成员为空的话，表示不支持特定的操作。</p>
<p>介绍下本文中使用的几个字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span></span></span><br></pre></td></tr></table></figure>

<p><em>file_operations</em> 的第一个字段不是一个操作，而是用来指定哪个模块用于该结构体，大多数情况下，这个成员被初始化为 <em>THIS_MODULE</em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br></pre></td></tr></table></figure>

<p>虽然对于文件来说，这个操作通常是第一个执行的，但是驱动并不是必须实现该操作。如果这个成员为 <em>NULL</em>，打开这个设备的话，就一定是成功的，但是对应的驱动程序并不会得到通知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br></pre></td></tr></table></figure>

<p>这个操作在 <em>file</em> 结构体被释放的时候被调用，和 <em>open</em> 一样，这个成员可以为 <em>NULL</em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>用来从设备中获取数据。如果这个成员为空的话，<em>read</em> 系统调用将会失败，并返回 <em>-EINVAL</em>。返回非负数代表本次调用成功读到的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>将数据写入到设备中。如果为空的话，<em>write</em> 系统调用也返回 <em>-EINVAL</em>。返回值如果为非负数，表示成功写入的字节数。</p>
<p><strong>membuff</strong> 的设备驱动只实现了几个重要的操作，它的 <em>file_operations</em> 结构体初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">membuf_ops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.<span class="built_in">open</span> = membuf_open,</span><br><span class="line">	.<span class="built_in">release</span> = membuf_release,</span><br><span class="line">	.<span class="built_in">read</span> = membuf_read,</span><br><span class="line">	.<span class="built_in">write</span> = membuf_write</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="④-file-结构体"><a href="#④-file-结构体" class="headerlink" title="④ file 结构体"></a>④ file 结构体</h4><p><em>struct file*，定义在 *&lt;linux/fs.h&gt;</em> 中，在设备驱动程序中是相当重要的数据结构。需要注意的是，<em>struct file</em> 和 <em>FILE</em> 是不一样的，<em>FILE</em> 是定义在C语言库中，不会出现在内核代码中。而 <em>struct file</em> 是内核的数据结构，不会出现在用户程序中。</p>
<p><em>struct file</em> 代表一个被打开的文件，它与设备驱动无特定关联。它是内核在调用 <em>open</em> 的时候创建的，在所有和文件相关的函数中作为参数使用，直到调用 <em>close</em>。</p>
<p>介绍下几个比较重要的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mode_t</span> f_mode;</span><br></pre></td></tr></table></figure>

<p>通过设置 <em>FMODE_READ</em> 或 <em>FMODE_WRITE</em> 表示该文件的打开模式，你可能会需要在 <em>open</em> 或者 <em>ioctl</em> 函数里面检查是否有读写的权限，但是在调用 <em>read</em> 和 <em>write</em> 的时候不需要检查，因为内核会在调用你的函数之前检查。尝试读写没有对应权限的文件的时候，会被直接拒绝，驱动程序根本不会知道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loff_t</span> f_pos;</span><br></pre></td></tr></table></figure>

<p>当前的读写位置，<em>loff_t</em> 在所有平台上都是一个64位的值。驱动程序如果需要知道当前位置的话，可以读该值，但是正常情况下，不能去修改它；<em>read</em> 和 <em>write</em> 通过设置它们最后一个参数的值来更新文件位置，而不应该直接修改 <em>f_pos*。这一点对于 *llseek</em> 方法的话不适用，因为它就是用来修改文件位置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br></pre></td></tr></table></figure>

<p>这个文件对应的操作。内核在它的 <em>open</em> 实现中对该值进行了赋值，当内核在派发操作的时候读取该字段。内核后续的引用该成员不会再修改它，也就意味着可以修改该文件关联的操作。这一点可以用在同一个主设备号，不同次设备号定义不同的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *private_data;</span><br></pre></td></tr></table></figure>

<p><em>open</em> 系统调用在调用驱动程序的 <em>open</em> 函数的时候，会将这个指针赋值为 <em>NULL*。这个指针可以忽略不用，也可以用来保存分配的内存，但是必须记得在 *release</em> 的时候将其释放。</p>
<h4 id="⑤-inode-结构体"><a href="#⑤-inode-结构体" class="headerlink" title="⑤ inode 结构体"></a>⑤ inode 结构体</h4><p><em>inode</em> 结构体是内核用来表示一个文件。因此，它和 <em>file</em> 结构体是不一样的，<em>file</em> 结构体是用来表示一个打开的文件描述符。同一个文件可以有很多 <em>file</em> 结构，来表示被打开的文件描述符，但是它们都指向都一个 <em>inode</em> 结构。</p>
<p><em>inode</em> 结构体里面包含很多文件相关的信息。通常情况下，写设备驱动的时候，只对两个成员有兴趣：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dev_t</span> i_rdev;</span><br></pre></td></tr></table></figure>

<p>对于描述设备文件的 <em>inode</em>，这个成员包含实际的设备号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">i_cdev</span>;</span></span><br></pre></td></tr></table></figure>

<p><em>struct cdev</em> 是内核内部用来描述字符设备的结构；当 <em>inode</em> 描述的是一个字符设备文件时，该成员指向内核中的结构。</p>
<h4 id="⑥-构造驱动所使用的结构体"><a href="#⑥-构造驱动所使用的结构体" class="headerlink" title="⑥ 构造驱动所使用的结构体"></a>⑥ 构造驱动所使用的结构体</h4><p>由于 <em>membuf</em> 使用内存来表示一个文件，所以需要在某些地方将内存的指针保存起来。通常的做法是构造一个结构体，用来保存和设备相关的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">membuf_dev</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>* pBuffer;</span><br><span class="line">	<span class="keyword">size_t</span> bufLen;</span><br><span class="line">	<span class="keyword">size_t</span> wroteLen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <em>inode</em> 结构中的 <em>i_cdev</em> 成员指向的是内核中的 <em>cdev</em> 结构，而内核中的 <em>cdev</em> 是由驱动在调用 <em>cdev_add</em> 的时候设置的，所以通常做法是在设备初始化的时候，分配一个 <em>membuf_dev</em> 结构体，然后调用 <em>cdev_add</em> 的时候，传入的是该结构体的成员的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pMembufDev = kmalloc(<span class="keyword">sizeof</span>(struct membuf_dev), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(pMembufDev, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct membuf_dev));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;(pMembufDev-&gt;dev), &amp;membuf_ops);</span><br><span class="line">pMembufDev-&gt;dev.owner = THIS_MODULE;</span><br><span class="line">pMembufDev-&gt;dev.ops = &amp;membuf_ops;</span><br><span class="line">devno = MKDEV(devMajor, devMinor);</span><br><span class="line"></span><br><span class="line">err = cdev_add(&amp;(pMembufDev-&gt;dev), devno, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>后续在调用 <em>open</em> 的时候，通过 <em>inode</em> 参数里面的 <em>i_cdev</em> 的地址，并进行一定的位移，计算出 <em>struct membuf_dev</em> 的地址，然后将其保存到 <em>struct file</em> 中的 <em>private_data</em> 成员，后续的 <em>read</em> 、<em>write</em> 操作通过 <em>private_data</em> 就可以拿到设备相关的信息，具体逻辑见打开文件。</p>
<p>由于对地址进行偏移，看起来是比较取巧的方法，有时候可能会产生误解，因此内核提供了 <em>container_of</em> 宏，其实质也就是对地址进行偏移来拿到整个结构体的地址，原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_of(pointer, container_type, container_field);</span><br></pre></td></tr></table></figure>

<h4 id="⑦-创建设备"><a href="#⑦-创建设备" class="headerlink" title="⑦ 创建设备"></a>⑦ 创建设备</h4><p>大多数情况下，都是给硬件设备做驱动，因此设备是已经存在的，但是这里的设备需要自己来创建。创建设备也很简单，可以通过 <em>mknod</em> 来创建字符设备，但是需要在命令行下来创建，如果是在 android 平台，还不一定有这个命令。</p>
<p>这里通过函数来直接创建，在设备驱动初始化的时候创建设备，反初始化的时候移除设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pMembufClass = class_create(THIS_MODULE, MEMORY_BUFF_CLASS_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pMembufClass)) &#123;</span><br><span class="line">	err = PTR_ERR(pMembufClass);</span><br><span class="line">	<span class="keyword">goto</span> destroy_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp = device_create(pMembufClass, <span class="literal">NULL</span>, devno, <span class="string">"%s"</span>, MEMORY_BUFF_FILE_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(temp)) &#123;</span><br><span class="line">	err = PTR_ERR(temp);</span><br><span class="line">	<span class="keyword">goto</span> destroy_class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-释放设备"><a href="#3-释放设备" class="headerlink" title="3. 释放设备"></a>3. 释放设备</h3><p>释放设备的逻辑和初始化逻辑相对应，但是没有初始化那么复杂。只需要将分配的内存和设备号都释放掉即可，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">membuff_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">dev_t</span> devno = MKDEV(devMajor, devMinor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pMembufClass) &#123;</span><br><span class="line">		device_destroy(pMembufClass, devno);</span><br><span class="line">		class_destroy(pMembufClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pMembufDev) &#123;</span><br><span class="line">		cdev_del(&amp;(pMembufDev-&gt;dev));</span><br><span class="line">		kfree(pMembufDev-&gt;pBuffer);</span><br><span class="line">		kfree(pMembufDev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-打开设备"><a href="#4-打开设备" class="headerlink" title="4. 打开设备"></a>4. 打开设备</h3><p>应用程序在打开一个文件的时候，传入的是一个路径，经过转换后，最终传入驱动的时候，是一个 <em>inode</em> 参数。由于可能存在一个驱动程序对应于多个设备，所以在 <em>open</em> 的时候需要将设备相关的信息关联到 <em>file*，这样后续的读写操作能够通过 *private_data</em> 拿到文件所关联的设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">membuf_open</span><span class="params">(struct inode* inode, struct file* filp)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">membuf_dev</span>* <span class="title">pMembufDev</span>;</span></span><br><span class="line"></span><br><span class="line">	pMembufDev = container_of(inode-&gt;i_cdev, struct membuf_dev, dev);</span><br><span class="line">	filp-&gt;private_data = pMembufDev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a>5. 编译</h3><p>为了将新写的驱动编进到android中，需要先将android系统及内核都编译一遍，建议使用ubuntu进行编译，编译流程见<a href="https://source.android.com/source/requirements.html" target="_blank" rel="noopener">这里</a>。</p>
<p>编译完成后，假设内核源代码目录名为 <em>common</em> ，在 <em>common/drivers</em> 下面创建一个目录 <em>membuff</em>，将源代码放到里面。</p>
<p>增加 <em>Makefile</em> 文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_MEMBUFF) +&#x3D; membuff.o</span><br></pre></td></tr></table></figure>

<p>增加 <em>Kconfig</em> 文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config MEMBUFF</span><br><span class="line">	tristate &quot;memory buffer driver&quot;</span><br><span class="line">	default n</span><br><span class="line">	help</span><br><span class="line">	This is a memory buffer driver.</span><br></pre></td></tr></table></figure>

<p>编译内核的原则是 <em>TANSTAAFL</em>（There Ain’t No Such Thing As A Free Lunch），任何编译进内核的内容都会增加它的大小，就算选的是以模块方式编译也是如此。所以编译内核的时候，需要配置需要编译哪些内容。</p>
<p>上面的 <em>Kconfig</em> 就是用来配置 <em>membuff</em> 的，第一行定义下面的内容是定义哪一项的，前缀 <em>CONFIG_</em> 是省略了。 <em>tristate</em> 表示它可以编译进内核（Y），也可以作为模块编译（M），也可以不编译（N）。第三行指定了默认值为不编译。</p>
<p>除此之外还需要修改 <em>arch/arm/Kconfig</em> 和 <em>drivers/kconfig</em> 两个文件，在 <em>menu “Device Drivers”</em> 和 <em>endmenu</em> 之间添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;drivers&#x2F;hello&#x2F;Kconfig&quot;</span><br></pre></td></tr></table></figure>

<p>然后在 <em>drivers/Makefile</em> 文件中，添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_HELLO) +&#x3D; hello&#x2F;</span><br></pre></td></tr></table></figure>

<p>添加完成后，就可以通过修改 <em>common/.config</em>，将里面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># CONFIG_MEMBUFF is not set</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MEMBUFF&#x3D;y</span><br></pre></td></tr></table></figure>

<p>如果没有 <em>.config</em> 文件，说明之前没有编译过内核，应该需要按照上面的指引编译一个与android系统相匹配的内核。比如如果要给 <em>ARMv7</em>  的模拟器编译内核，可以通过 <em>make goldfish_armv7_defconfig</em> 生成 <em>ARMv7</em> 对应的内核编译配置文件 <em>.config</em>。</p>
<p>编译完成后，就可以在启动模拟器的时候，指定使用新的内核了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -kernel common&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;zImage</span><br></pre></td></tr></table></figure>


</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cosinus Wx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">链接: </span><span class="post-copyright-info"><a href="https://blog.cosinuswx.com/posts/2952791095/">https://blog.cosinuswx.com/posts/2952791095/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权所有: </span><span class="post-copyright-info">除非另有说明，本博客所有文章均遵循<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a>协议.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/posts/324364040/"><i class="fa fa-chevron-left">  </i><span>RenderScript的基础使用</span></a></div><div class="next-post pull-right"><a href="/posts/1734405025/"><span>java中的枚举类型解析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Cosinus Wx</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>