<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="RenderScript的基础使用"><meta name="keywords" content="android"><meta name="author" content="Cosinus Wx"><meta name="copyright" content="Cosinus Wx"><title>RenderScript的基础使用 | Cosinus.Wx's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '已复制',
    error: '复制失败',
    noSupport: '浏览器不支持复制'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="显示文章目录">显示博客信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">当前已读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-工程配置"><span class="toc-text">1. 工程配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-脚本语言"><span class="toc-text">2. 脚本语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-脚本编译"><span class="toc-text">3. 脚本编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java层的接口"><span class="toc-text">4. Java层的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-执行"><span class="toc-text">5. 执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderScript"><span class="toc-text">RenderScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScriptC-Gray"><span class="toc-text">ScriptC_Gray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocation"><span class="toc-text">Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach-root"><span class="toc-text">forEach_root</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-变量"><span class="toc-text">6. 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-总结"><span class="toc-text">7. 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">Cosinus Wx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">快速访问</div><a class="author-info-links__name text-center" href="/about">关于</a><a class="author-info-links__name text-center" href="/atom.xml">RSS</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Cosinus.Wx's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">HOME</a><a class="site-page" href="/archives">ARCHIVES</a><a class="site-page" href="/tags">TAGS</a><a class="site-page" href="/categories">CATEGORIES</a><a class="site-page" href="/about">ABOUT</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">RenderScript的基础使用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-10-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/android/"> android</a></div><div class="article-container" id="post-content"><p>Renderscript是Android操作系统上的一套API。它基于异构计算思想（指使用不同类型指令集和体系架构的计算单元组成系统的计算方式），专门用于密集型计算，尤其是图像处理、计算机图形、计算机视觉。允许开发者以较少的代码实现功能复杂且性能优越的应用程序。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>RenderScript可在设备上所有可用的处理器上并行执行，例如多核CPU、GPU、DSP，所以开发者可以专心写处理算法，而不需要关心调度和负载平衡的问题。</p>
<a id="more"></a>

<p>本文通过写一个简单的例子（<a href="https://github.com/cosinuswx/AndroidMisc" target="_blank" rel="noopener">源码链接</a>）来解释怎么使用RenderScript，例子中将彩色的图片转换为黑白的，为了测试RenderScript的性能，加上手指滑动的效果，如下图：</p>
<p><img src="/images/renderscript/render_script_graying.webp" alt=""></p>
<h2 id="1-工程配置"><a href="#1-工程配置" class="headerlink" title="1. 工程配置"></a>1. 工程配置</h2><p>RenderScript的api从Android 3.0（Api level 11）开始系统自带了，在低于3.0的机器上，可以通过support包来使用RenderScript。但是还是推荐都使用support的RenderScript，因为RenderScript可能会有bug，使用support包能够及时得到更新。本文均使用support包中的Api。</p>
<p>要使用RenderScript，除了要导入一个jar包外，还需要复制一些so文件，如果使用gradle的话，就方便一些，只需要在build.gradle文件中增加两句：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">19</span></span><br><span class="line">    buildToolsVersion <span class="string">"19.0.3"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">8</span></span><br><span class="line">        targetSdkVersion <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        renderscriptTargetApi <span class="number">18</span></span><br><span class="line">        renderscriptSupportModeEnabled <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两句设置会导致在android编译的时候，有一些特殊的流程：</p>
<ul>
<li><strong>renderscriptTargetApi</strong>：设置生成的字节码的版本，推荐使用最高的API Level，并且设置renderscriptSupportModeEnabled为true。这个选项的合法值从11到最新发布的API Level。如果你的最低SDK的版本和这个值不一样，这个值就会被忽略，在编译的时候，这个值会被设置了最低的SDK版本。</li>
<li><strong>renderscriptSupportModeEnabled</strong>：指定在运行的设备不是target version的时候，生成的字节码需要回滚到兼容的版本。</li>
<li><strong>buildToolsVersion</strong>：需要使用的Android SDK的编译工具的版本，这个值需要设置为18.1.0或者更高。如果这个值没有指定，那么将使用当前已安装的最高版本。这个值最好设置，防止不同开发者的机器配置不同，导致奇怪的编译问题。</li>
</ul>
<h2 id="2-脚本语言"><a href="#2-脚本语言" class="headerlink" title="2. 脚本语言"></a>2. 脚本语言</h2><p>为了能在多个平台执行，RenderScript要求开发者使用Rs的脚本语言来实现计算的代码，脚本代码采用了c99语法，所以看起来和C语言很像。代码要求放在.rs文件中，文件需要放在 <em>&lt;project_root&gt;/src/</em> 中，脚本包含脚本的入口、函数和变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> version(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> rs java_package_name(com.winomtech.androidmisc.rs)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">root</span><span class="params">(<span class="keyword">const</span> uchar4 *in, uchar4 *out, <span class="keyword">uint32_t</span> x, <span class="keyword">uint32_t</span> y)</span> </span>&#123;</span><br><span class="line">    out-&gt;r = out-&gt;g = out-&gt;b = (in-&gt;r + in-&gt;g + in-&gt;b) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>#pragma version(1)</em> 声明脚本中使用的Rs的版本。<em>#pragma rs java_package_name</em> 声明脚本生成的Java层的代码所在的包名，这个将在后面再细讲。</p>
<p><em>root</em>（Kernel）函数是rs脚本默认的入口，这种入口函数在rs中称为Kernel函数，默认的Kernel函数名为<em>root</em>，且必须返回<em>void</em>，并且有以下的参数：</p>
<ul>
<li>指向rs脚本输入输出的内存的指针。在Android 3.2(Api Level 13)或者更早的版本，这两个参数都需要，Android 4.0(Api Level 14)及以后的版本要求一个或两个。</li>
</ul>
<p>下面的参数是可选的，但是如果你选择使用它们，则都需要提供：</p>
<ul>
<li>rs脚本用来实现计算的附加数据的指针，可以是原始类型的指针，也可以是复杂的结构体的指针。</li>
<li>附加数据的大小</li>
</ul>
<p>从Android 4.1 (Api level 16)开始，可以自己定义kernel函数的参数，而不必和前面描述参数及返回值一样。并且可以在同一个脚本中定义多个kernel函数，但是需要在自定义的kernel函数前面增加 __attribute__((kernel))。例如，下面是一个kernel函数，接收两个 uint32_t 类型的参数，返回一个uchar4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uchar4 __attribute__((kernel)) root(<span class="keyword">uint32_t</span> x, <span class="keyword">uint32_t</span> y) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数类型uchar4是rs中一类数据类型，称为Vector。Vector通常是普通类型接着2、3、4，比如：float4, int3, double2, ulong4。Vector类型中的成员可以使用多种风格来访问：变量名接着一个点，再接着：</p>
<ul>
<li>字符x、y、z和w</li>
<li>字符r、g、b和a</li>
<li>字符s或S，随后接着从0开始的下标</li>
</ul>
<p>uint32_t x、uint32_t y两个参数是当前执行到的下标，这两个参数是可选的，最多可以有三维x、y、z，类型必须为uint32_t。</p>
<p>init函数是一个可选的函数，在kernel函数执行前，init函数会被执行一次，可以在init里面做一些初始化的工作，比如初始化变量。</p>
<h2 id="3-脚本编译"><a href="#3-脚本编译" class="headerlink" title="3. 脚本编译"></a>3. 脚本编译</h2><p>脚本在执行之前会有两次编译：在android编译的过程中，会发生第一次编译，生成LLVM的字节码；当应用在设备中执行的时候，会发生第二次编译，生成设备的机器码。</p>
<h2 id="4-Java层的接口"><a href="#4-Java层的接口" class="headerlink" title="4. Java层的接口"></a>4. Java层的接口</h2><p>因为脚本最后会被编译为机器码，为了方便Java层设置数据和调用接口，rs在android编译的时候，会生成一个java文件，名字为ScriptC_<em>script_name</em>，比如Gray.rs文件，会自动生成一个ScriptC_Gary.java。下面代码是上面rs脚本生成的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptC_Gray</span> <span class="keyword">extends</span> <span class="title">ScriptC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String __rs_resource_name = <span class="string">"gray"</span>;</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ScriptC_Gray</span><span class="params">(RenderScript rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(rs,</span><br><span class="line">             rs.getApplicationContext().getResources(),</span><br><span class="line">             rs.getApplicationContext().getResources().getIdentifier(</span><br><span class="line">                 __rs_resource_name, <span class="string">"raw"</span>,</span><br><span class="line">                 rs.getApplicationContext().getPackageName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ScriptC_Gray</span><span class="params">(RenderScript rs, Resources resources, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(rs, resources, id);</span><br><span class="line">        __U8_4 = Element.U8_4(rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Element __U8_4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> mExportForEachIdx_root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> Script.<span class="function">KernelID <span class="title">getKernelID_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createKernelID(mExportForEachIdx_root, <span class="number">27</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach_root</span><span class="params">(Allocation ain, Allocation aout)</span> </span>&#123;</span><br><span class="line">        forEach_root(ain, aout, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach_root</span><span class="params">(Allocation ain, Allocation aout, Script.LaunchOptions sc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check ain</span></span><br><span class="line">        <span class="keyword">if</span> (!ain.getType().getElement().isCompatible(__U8_4)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RSRuntimeException(<span class="string">"Type mismatch with U8_4!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check aout</span></span><br><span class="line">        <span class="keyword">if</span> (!aout.getType().getElement().isCompatible(__U8_4)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RSRuntimeException(<span class="string">"Type mismatch with U8_4!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Type t0, t1;        <span class="comment">// Verify dimensions</span></span><br><span class="line">        t0 = ain.getType();</span><br><span class="line">        t1 = aout.getType();</span><br><span class="line">        <span class="keyword">if</span> ((t0.getCount() != t1.getCount()) ||</span><br><span class="line">            (t0.getX() != t1.getX()) ||</span><br><span class="line">            (t0.getY() != t1.getY()) ||</span><br><span class="line">            (t0.getZ() != t1.getZ()) ||</span><br><span class="line">            (t0.hasFaces()   != t1.hasFaces()) ||</span><br><span class="line">            (t0.hasMipmaps() != t1.hasMipmaps())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RSRuntimeException(<span class="string">"Dimension mismatch between parameters ain and aout!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        forEach(mExportForEachIdx_root, ain, aout, <span class="keyword">null</span>, sc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码继承于ScriptC，其中有一些变量和函数名都有_root的后缀，这个后缀的root其实就是kernel函数的名字，如果一个rs脚本中有多个kernel函数，比如有一个名为test的kernel函数，那么就有一些函数和变量名有_test后缀。</p>
<p>getKernelID_root这个是返回root的id，这个id是RenderScript框架所使用的。有时候需要在一个Kernel函数执行完后，再执行另外一个时，就需要使用到它。</p>
<p>forEach_root函数是用来调用Kernel函数执行的入口，在执行之前，会检查输入和输出是否和脚本中的类型一致，如果不一致直接抛出异常，同时还会检查输入和输出的维度是否一致。</p>
<h2 id="5-执行"><a href="#5-执行" class="headerlink" title="5. 执行"></a>5. 执行</h2><p>下面代码是缩减后的代码，仅作讲解使用，代码的主要作用是用输入的图片生成一张黑白的图片，并且显示在界面上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Bitmap mInBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.renderscript_input);</span><br><span class="line">Bitmap mOutBitmap = Bitmap.createBitmap(mInBitmap.getWidth(), mInBitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">RenderScript mRenderScript = RenderScript.create(getActivity());</span><br><span class="line">ScriptC_Gray mGrayScript = <span class="keyword">new</span> ScriptC_Gray(mRenderScript);</span><br><span class="line"></span><br><span class="line">Allocation mAllocationIn = Allocation.createFromBitmap(mRenderScript, mInBitmap);</span><br><span class="line">Allocation mAllocationOut = Allocation.createFromBitmap(mRenderScript, mOutBitmap);</span><br><span class="line"></span><br><span class="line">mGrayScript.forEach_root(mAllocationIn, mAllocationOut);</span><br><span class="line">mAllocationOut.copyTo(mOutBitmap);</span><br><span class="line">mImageView.setImageBitmap(mOutBitmap);</span><br></pre></td></tr></table></figure>

<h3 id="RenderScript"><a href="#RenderScript" class="headerlink" title="RenderScript"></a>RenderScript</h3><p>这个类用来访问RenderScript的上下文，管理RenderScript的初始化、资源、以及生命周期的。在任何其他RS对象使用之前，需要创建一个RenderScript对象，并且需要缓存这个对象，以方便后续使用。当进程完成使用RenderScript的任务的时候，需要调用releaseAllContexts。</p>
<p>通过调用RenderScript.create静态方式，可以得到RenderScript的对象。在Api 23的时候，多次调用create得到的会是同样的对象，所以能够得到同样的上下文，以及同样的配置。在Api 23之前，每次调用create将生成一个新的上下文。</p>
<h3 id="ScriptC-Gray"><a href="#ScriptC-Gray" class="headerlink" title="ScriptC_Gray"></a>ScriptC_Gray</h3><p>上文已讲到。</p>
<h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p>应用程序在Android虚拟机上使用RenderScript，但是实际的rs脚本在native层执行，并且需要访问Android虚拟机分配的内存。为此，就需要将虚拟机层分配的内存和RenderScript runtime连接起来，这个过程称为绑定，然后RenderScript runtime就可以方便的使用它需要的内存了，而不需要显式的分配。最终的结果就好像你在C中调用了malloc一样。</p>
<p>为了支持这种内存分配的方式，提供了一组API给Android VM来分配内存，类似于malloc函数的功能。这些类本质是描述应该怎么分配内存以及执行真正的分配。为了更好的理解这些类是怎么工作的，我们看看它们与malloc的关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个malloc调用可以分为两个部分：分配的内存单元的大小（sizeof(int)），分配的单元的个数。Android框架提供了类似于这两部分的类，以及类似malloc的类。</p>
<p>Element类代表malloc中的分配单元，例如浮点类型或者一个结构体。Type类对Element和分配的个数进行包装，可以将Type想象成Element的数组。而Allocation类基于给定的Type执行真正的内存分配，以及访问分配的内存。</p>
<p>Type由5个维度组成：X、Y、Z、LOD(level of detail)和Faces(of a cube map)。可以设置X、Y、Z为任意正整数，但是要限制在可用内存的范围内。如果某个维度的值为0，表示没有那个维度，例如：x=10、y=1、z=0表示二维。LOD和Faces用boolean值来表示是否出现了。</p>
<p>Allocation.createFromBitmap是对分配操作的封装，会根据Bitmap的配置来指定对于的Element的值，以及Type的值，并且用Bitmap的宽高来指定x、y的值。</p>
<h3 id="forEach-root"><a href="#forEach-root" class="headerlink" title="forEach_root"></a>forEach_root</h3><p>forEach_root中两个参数分别指定输入和输出，RenderScript会根据输入参数中的维度，遍历整个数组，对每个数值都调用一次Kernel函数，所以rs文件中的in、out、x、y是根据当前遍历的位置的不同而不同。</p>
<h2 id="6-变量"><a href="#6-变量" class="headerlink" title="6. 变量"></a>6. 变量</h2><p>在前面的rs文件中，只指定了输入和输出，当需要外部传入多个参数时，就需要使用rs的变量了。本文的例子中，除了要指定输入输出，还需要指定从哪个位置开始是需要变灰的，所以我们在rs脚本中增加一个变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> version(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> rs java_package_name(com.winomtech.androidmisc.rs)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gPos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再编译下android工程，我们再看生成的java代码，会多出来两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set_gPos</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    setVar(mExportVarIdx_gPos, v);</span><br><span class="line">    mExportVar_gPos = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_gPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mExportVar_gPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java层就可以通过这两个接口来访问rs中的gPos变量了。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>RenderScript用起来还算挺简单的，当然也主要是本文实现功能简单。当然RenderScript的作用还是很容易看出来的，可以写一个长循环，然后看cpu使用，在我的手机上面，4个核心可以跑满，而如果使用jni的话，很明显只会在一个核心上面跑。</p>
<p>参考资料：</p>
<p><a href="http://developer.android.com/guide/topics/renderscript/index.html" target="_blank" rel="noopener">http://developer.android.com/guide/topics/renderscript/index.html</a></p>
<p><a href="https://stuff.mit.edu/afs/sipb/project/android/docs/guide/topics/renderscript/index.html" target="_blank" rel="noopener">https://stuff.mit.edu/afs/sipb/project/android/docs/guide/topics/renderscript/index.html</a> 这个链接是旧的版本，但是里面有些内容是前面那个没提到的。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cosinus Wx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">链接: </span><span class="post-copyright-info"><a href="https://blog.cosinuswx.com/posts/324364040/">https://blog.cosinuswx.com/posts/324364040/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权所有: </span><span class="post-copyright-info">除非另有说明，本博客所有文章均遵循<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a>协议.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/posts/1763227376/"><i class="fa fa-chevron-left">  </i><span>【译】Android图形架构</span></a></div><div class="next-post pull-right"><a href="/posts/2952791095/"><span>测试给andorid编写驱动</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Cosinus Wx</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>